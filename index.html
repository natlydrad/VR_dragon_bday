<!DOCTYPE html>
<html>
<head>
    <title>Voxel Models in VR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background-color: #000; font-family: sans-serif; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1. Scene Setup
        const scene = new THREE.Scene();
        
        // Create sky gradient background (Galeton-inspired: blue sky)
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x87CEEB) }, // Sky blue
                bottomColor: { value: new THREE.Color(0xE0F6FF) }, // Light blue
                offset: { value: 0.3 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position camera to view the model (looking at origin initially)
        camera.position.set(0, 0, 5); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // 2. Enable XR
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Add the VR Button to the page
        document.body.appendChild(VRButton.createButton(renderer));

        // 3. Lights & Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0); // Target the origin initially
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.update();

        // Create Galeton-inspired landscape: Big, close mountains wrapping around, Lake, and Snow
        // Create 3D mountains
        function createMountain(baseWidth, height, x, z, color = 0x5a5a4a) {
            const geometry = new THREE.ConeGeometry(baseWidth, height, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                flatShading: true
            });
            const mountain = new THREE.Mesh(geometry, material);
            mountain.position.set(x, height / 2, z);
            return mountain;
        }
        
        // Create fewer, bigger mountains - nestled but not too close
        const mountains = new THREE.Group();
        const frontColor = 0x5a5a4a; // Gray-green for front mountains
        const backColor = 0x2a3a5a; // Dark blue for back mountains
        
        // Left side - big mountains (front color)
        mountains.add(createMountain(12, 5, -14, -12, frontColor));
        mountains.add(createMountain(10, 4.5, -16, -10, frontColor));
        mountains.add(createMountain(11, 4.8, -15, -8, frontColor));
        
        // Back - big mountains (dark blue)
        mountains.add(createMountain(14, 5.5, -8, -14, backColor));
        mountains.add(createMountain(13, 5.2, 0, -15, backColor));
        mountains.add(createMountain(12, 5, 8, -14, backColor));
        
        // Right side - big mountains (front color)
        mountains.add(createMountain(12, 5.2, 14, -12, frontColor));
        mountains.add(createMountain(10, 4.6, 16, -10, frontColor));
        mountains.add(createMountain(11, 4.9, 15, -8, frontColor));
        
        scene.add(mountains);
        
        // Ground/grass base
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7a9a8a }); // Lighter, more wintery
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.49;
        scene.add(ground);
        
        // Lake (circular body of water) - smaller, to the right
        const lakeRadius = 4.8; // Smaller lake
        const lakeGeometry = new THREE.CircleGeometry(lakeRadius, 32);
        const lakeMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x4a7fa8, // Water blue
            transparent: true,
            opacity: 0.8
        });
        const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
        lake.rotation.x = -Math.PI / 2;
        lake.position.set(6, -0.48, -4); // Position lake to the right
        scene.add(lake);
        
        // Ice patches around the lake
        function createIcePatch(size, x, z) {
            const iceGeometry = new THREE.CircleGeometry(size, 16);
            const iceMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xE0F6FF, // Light blue-white ice
                transparent: true,
                opacity: 0.7
            });
            const ice = new THREE.Mesh(iceGeometry, iceMaterial);
            ice.rotation.x = -Math.PI / 2;
            ice.position.set(x, -0.47, z);
            return ice;
        }
        
        const iceGroup = new THREE.Group();
        // Ice patches around the smaller lake edge (adjusted for lake position to the right)
        iceGroup.add(createIcePatch(1.5, 4, -4));
        iceGroup.add(createIcePatch(1.2, 8, -3));
        iceGroup.add(createIcePatch(1.3, 5, -1));
        iceGroup.add(createIcePatch(1.0, 7.5, -2));
        iceGroup.add(createIcePatch(1.2, 6, -6));
        iceGroup.add(createIcePatch(1.0, 3.5, -5));
        iceGroup.add(createIcePatch(1.1, 8.5, -5));
        scene.add(iceGroup);
        
        // Snow patches on the ground (away from lake) - make them look like actual snow
        function createSnowPatch(size, x, z) {
            const snowGroup = new THREE.Group();
            
            // Snow base (slightly elevated to sit on ground)
            const snowGeometry = new THREE.CylinderGeometry(size, size, 0.1, 16);
            const snowMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF8F8FF, // Bright white with slight blue tint for snow
                emissive: 0x222222 // Slight glow to make it stand out
            });
            const snow = new THREE.Mesh(snowGeometry, snowMaterial);
            snow.rotation.x = Math.PI / 2;
            snow.position.set(x, -0.45, z);
            snowGroup.add(snow);
            
            return snowGroup;
        }
        
        const snowGroup = new THREE.Group();
        // Snow patches scattered around (not on the lake)
        snowGroup.add(createSnowPatch(3, -10, -8));
        snowGroup.add(createSnowPatch(2.5, 8, -10));
        snowGroup.add(createSnowPatch(2.8, -6, 2));
        snowGroup.add(createSnowPatch(2.2, 10, 4));
        snowGroup.add(createSnowPatch(2.5, 0, 6));
        snowGroup.add(createSnowPatch(2, -8, 4));
        scene.add(snowGroup);
        
        // Natural lighting for Galeton scene
        scene.add(new THREE.HemisphereLight(0x87CEEB, 0x6b8e5a, 1.2)); // Sky and ground colors
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(5, 10, 5);
        sunLight.castShadow = false;
        scene.add(sunLight);

        // 4. Load both models
        const loader = new VOXLoader();
        const allModelsGroup = new THREE.Group();
        const modelGroups = [];
        let modelsLoaded = 0;
        const totalModels = 2;
        
        function loadModel(filename, index) {
            console.log('Loading voxel file:', filename);
            loader.load(
                filename,
                (chunks) => {
                    console.log('VOX file loaded successfully!', filename, 'Chunks:', chunks.length);
                    const group = new THREE.Group();
                    chunks.forEach((chunk) => {
                        const mesh = new VOXMesh(chunk);
                        mesh.scale.setScalar(0.02); // Adjust this if the model is too big/small
                        group.add(mesh);
                    });
                    
                    modelGroups[index] = group;
                    modelsLoaded++;
                    
                    if (modelsLoaded === totalModels) {
                        // Both models loaded, calculate bounding boxes to determine spacing
                        const box0 = new THREE.Box3().setFromObject(modelGroups[0]);
                        const box1 = new THREE.Box3().setFromObject(modelGroups[1]);
                        const size0 = box0.getSize(new THREE.Vector3());
                        const size1 = box1.getSize(new THREE.Vector3());
                        
                        // Tilt models slightly towards each other (cute!)
                        modelGroups[0].rotation.y = Math.PI / 12; // Left model tilts right (15 degrees)
                        modelGroups[1].rotation.y = -Math.PI / 12; // Right model tilts left (-15 degrees)
                        
                        // Recalculate bounding boxes after rotation
                        box0.setFromObject(modelGroups[0]);
                        box1.setFromObject(modelGroups[1]);
                        const size0Rotated = box0.getSize(new THREE.Vector3());
                        const size1Rotated = box1.getSize(new THREE.Vector3());
                        
                        // Position models side by side so they're touching
                        // drag_gale (left) and nat_gale (right)
                        const w0 = size0Rotated.x; // width of drag_gale (x dimension)
                        const w1 = size1Rotated.x; // width of nat_gale (x dimension)
                        modelGroups[0].position.set(-w1 / 2, 0, 0);
                        modelGroups[1].position.set(w0 / 2, 0, 0);
                        
                        // Add both models to the group
                        allModelsGroup.add(modelGroups[0]);
                        allModelsGroup.add(modelGroups[1]);
                        scene.add(allModelsGroup);
                        
                        // Calculate bounding box for both models combined
                        const box = new THREE.Box3().setFromObject(allModelsGroup);
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());
                        
                        console.log('Combined models size:', size);
                        console.log('Combined models center:', center);
                        
                        // Calculate camera distance so models take up 1/3 of screen height
                        const fov = camera.fov * (Math.PI / 180); // Convert to radians
                        const modelHeight = size.y;
                        const desiredScreenFraction = 1/3; // 1/3 of screen height
                        const distance = (modelHeight / 2) / Math.tan(fov / 2) / desiredScreenFraction;
                        
                        // Position camera at calculated distance, looking at model center
                        camera.position.set(center.x, center.y, center.z + distance);
                        controls.target.copy(center);
                        controls.update();
                        
                        console.log('Camera positioned at distance:', distance);
                        
                        // Create pixel-style text "Happy Birthday, Dragon!"
                        function createPixelText(text) {
                            // Use low resolution for pixelated effect
                            const scale = 4; // Scale factor for pixelation
                            const baseWidth = 320;
                            const baseHeight = 40;
                            const canvas = document.createElement('canvas');
                            canvas.width = baseWidth * scale;
                            canvas.height = baseHeight * scale;
                            const ctx = canvas.getContext('2d');
                            
                            // Disable image smoothing for pixel-perfect rendering
                            ctx.imageSmoothingEnabled = false;
                            
                            // Scale up the context
                            ctx.scale(scale, scale);
                            
                            // Use a small font size for pixelated look
                            ctx.font = 'bold 16px monospace';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // White text with black outline for visibility
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 2;
                            ctx.strokeText(text, baseWidth / 2, baseHeight / 2);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillText(text, baseWidth / 2, baseHeight / 2);
                            
                            const texture = new THREE.CanvasTexture(canvas);
                            texture.magFilter = THREE.NearestFilter;
                            texture.minFilter = THREE.NearestFilter;
                            texture.needsUpdate = true;
                            return texture;
                        }
                        
                        const textTexture = createPixelText('Happy Birthday, Dragon!');
                        const textMaterial = new THREE.MeshBasicMaterial({
                            map: textTexture,
                            transparent: true,
                            alphaTest: 0.1
                        });
                        
                        const textGeometry = new THREE.PlaneGeometry(2, 0.25);
                        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                        
                        // Position text much closer above the models
                        textMesh.position.set(center.x, center.y + size.y / 2 + 0.15, center.z);
                        scene.add(textMesh);
                    }
                },
                (progress) => {
                    console.log('Loading progress:', filename, progress);
                },
                (error) => {
                    console.error('Error loading VOX file:', filename, error);
                    alert(`Error loading ${filename} file. Please check:\n1. The file exists in the same folder\n2. You are running a local server (not opening file:// directly)\n3. Check the browser console for details`);
                }
            );
        }
        
        // Load drag_gale (index 0) and nat_gale (index 1)
        loadModel('drag_gale_0.vox', 0); // Left side
        loadModel('nat_gale_1.vox', 1);  // Right side

        // 5. Render Loop (works for both desktop and VR)
        renderer.setAnimationLoop(function () {
            controls.update(); // Update controls on each frame
            renderer.render(scene, camera);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>