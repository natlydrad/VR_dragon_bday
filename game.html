<!DOCTYPE html>
<html>
<head>
    <title>Dragon's Birthday Adventure - Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background-color: #000; font-family: sans-serif; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFFF8E7); // Warm Studio Ghibli background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.update();
        
        // Function to save camera position for game view
        function saveGameCameraPosition() {
            const cameraData = {
                position: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                target: {
                    x: controls.target.x,
                    y: controls.target.y,
                    z: controls.target.z
                }
            };
            localStorage.setItem('gameCameraPosition', JSON.stringify(cameraData));
            console.log('Game camera position saved!');
        }
        
        // Function to load camera position for game view
        function loadGameCameraPosition() {
            const saved = localStorage.getItem('gameCameraPosition');
            if (saved) {
                try {
                    const cameraData = JSON.parse(saved);
                    camera.position.set(cameraData.position.x, cameraData.position.y, cameraData.position.z);
                    controls.target.set(cameraData.target.x, cameraData.target.y, cameraData.target.z);
                    controls.update();
                    return true;
                } catch (e) {
                    console.error('Error loading game camera position:', e);
                }
            }
            return false;
        }
        
        // Allow saving camera position with 'S' key in game view
        window.addEventListener('keydown', (event) => {
            if (event.key === 'S' || event.key === 's') {
                saveGameCameraPosition();
            }
        });

        // Lighting
        scene.add(new THREE.HemisphereLight(0xFFF8E7, 0xE8F5E9, 1.5));
        const sunLight = new THREE.DirectionalLight(0xFFF8DC, 2.0);
        sunLight.position.set(3, 8, 4);
        scene.add(sunLight);
        const characterLight = new THREE.PointLight(0xFFF8DC, 2.5, 15);
        characterLight.position.set(0, 2, 3);
        scene.add(characterLight);
        scene.add(new THREE.AmbientLight(0xFFFFFF, 0.8));

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xE8F5E9 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        scene.add(ground);

        // Load nat_gale character
        const loader = new VOXLoader();
        loader.load('nat_gale_1.vox', (chunks) => {
            const group = new THREE.Group();
            chunks.forEach((chunk) => {
                const mesh = new VOXMesh(chunk);
                mesh.scale.setScalar(0.02);
                group.add(mesh);
            });
            
            // Position character on the ground
            const box = new THREE.Box3().setFromObject(group);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const minY = box.min.y;
            
            // Position character so its bottom sits on the ground (y=0)
            // Position character slightly to the left to make room for text bubble
            const characterOffsetX = -1; // Move character slightly left
            group.position.set(characterOffsetX, -minY, 0);
            scene.add(group);
            
            // Recalculate center after positioning
            box.setFromObject(group);
            const newCenter = box.getCenter(new THREE.Vector3());
            
            // Try to load saved game camera position first, otherwise use calculated position
            const hasSavedPosition = loadGameCameraPosition();
            
            if (!hasSavedPosition) {
                // Calculate camera position - further back so text is readable
                const fov = camera.fov * (Math.PI / 180);
                const modelHeight = size.y;
                // Position camera further back for a comfortable view
                const distance = (modelHeight / 2) / Math.tan(fov / 2) * 3.5; // Further back view
                camera.position.set(newCenter.x, newCenter.y + 0.3, newCenter.z + distance);
                controls.target.copy(newCenter);
                controls.update();
                console.log('Game camera positioned at calculated distance:', distance);
            } else {
                console.log('Loaded saved game camera position');
            }
            
            // Create text bubble
            function createTextBubble(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Draw speech bubble background (white rounded rectangle, no triangle)
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                
                // Draw rounded rectangle (no tail needed)
                const x = 20;
                const y = 20;
                const width = canvas.width - 40;
                const height = canvas.height - 40;
                const radius = 20;
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw text
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 28px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            }
            
            const bubbleTexture = createTextBubble("Hello! Ready for an adventure?");
            const bubbleMaterial = new THREE.MeshBasicMaterial({
                map: bubbleTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const bubbleGeometry = new THREE.PlaneGeometry(2, 1);
            const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
            // Position bubble to the right of the character, close together, at character's head height
            // Calculate position based on character's right side
            const bubbleOffsetX = characterOffsetX + size.x / 2 + 1; // Right side of character + spacing
            bubble.position.set(bubbleOffsetX, newCenter.y + size.y * 0.6, newCenter.z);
            // Don't rotate - let it face forward naturally (PlaneGeometry faces +Z by default)
            scene.add(bubble);
        });

        // Render loop
        renderer.setAnimationLoop(function () {
            controls.update();
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
